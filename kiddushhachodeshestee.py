# -*- coding: utf-8 -*-
"""KiddushHachodeshEstee.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14TeRIlcIRGBPbcKHeO9kAuJ3cY8bFuDN

# Hebrew to Gregorian and Gregorian to Hebrew date converter

Coding assignment for week 2:
Write a python code that converts between Hebrew and Gregorian calendar for any date in the past or future. To make it slightly simpler, assume that both calendars have been the same as they are today for all of history (i.e., ignore the confusing Julian-Gregorian transition in 1582).
For example, if I enter "June 17, 2007" it will tell me "Tammuz 1, 5767"
or "December 25, 1 CE" will give "Tevet 23, 3762" (even though neither calendar was fixed 2000 years ago)
"""

# Calculate how many months have passed since molad Tohu: 
def monthsSinceMoladTohu(hYear, hMonth):
  # Create a varible to store the amount of months passed:
  ttlMonths = 0 
  
  # Find how many full 19-year cycles have passed: 
  fullCyclesPassed = (hYear-1)//19
  
  # Find how many parital cycles have passed:
  curYearInCycle = hYear - (19*fullCyclesPassed)
  if curYearInCycle == 0:
    yearsInParitalCyclePassed = 18
    curYearInCycle = 19
  else:
    yearsInParitalCyclePassed = curYearInCycle - 1
  
  # Add the months in the full 19-year cycles to total months. 
  # There are 235 months in a 19 year cycle:
  ttlMonths += (fullCyclesPassed*235)

  # Find how many leap years and non leap years in the current cycle have passed:
  leapYearsPassed = 0

  if yearsInParitalCyclePassed < 3: leapYearsPassed = 0
  elif yearsInParitalCyclePassed < 6: leapYearsPassed = 1
  elif yearsInParitalCyclePassed < 8: leapYearsPassed = 2
  elif yearsInParitalCyclePassed < 11: leapYearsPassed = 3
  elif yearsInParitalCyclePassed < 14: leapYearsPassed =  4
  elif yearsInParitalCyclePassed < 17: leapYearsPassed = 5
  elif yearsInParitalCyclePassed < 19: leapYearsPassed = 6
  elif yearsInParitalCyclePassed == 19: leapYearsPassed = 7 

  nonLeapYearsPassed = yearsInParitalCyclePassed - leapYearsPassed
  
  # Add the months in the yearsInParitalCyclePassed to total months. A non-leap year 
  # is 12 months and a leap year is 13 months:
  ttlMonths += ((nonLeapYearsPassed*12) + (leapYearsPassed*13))

  # Find out if this year is a leap year. Leap years are years 3, 6, 8, 11, 14, 
  # 17, and 19 in the cycle 
  if curYearInCycle in [3,6,8,11,14,17,19]:
    curleapYear = True 
  else:
    curleapYear = False 

  # Find how many months have passed in the current year.
  # This is not neccesacry when calculating the molad for the year.
  if hMonth == "Nissan" and not curleapYear:
    curMonth = 7
  elif hMonth == "Nissan" and curleapYear:
    curMonth = 8
  elif hMonth == "Iyar" and not curleapYear:
    curMonth = 8
  elif hMonth == "Iyar" and curleapYear:
    curMonth = 9
  elif hMonth == "Sivan" and not curleapYear:
    curMonth = 9
  elif hMonth == "Sivan" and curleapYear:
    curMonth = 10
  elif hMonth == "Tammuz" and not curleapYear:
    curMonth = 10
  elif hMonth == "Tammuz" and curleapYear:
    curMonth = 11
  elif hMonth == "Av" and not curleapYear:
    curMonth = 11
  elif hMonth == "Av" and curleapYear:
    curMonth = 12
  elif hMonth == "Elul" and not curleapYear:
    curMonth = 12
  elif hMonth == "Elul" and curleapYear:
    curMonth = 13
  elif hMonth == "Tishrei":
    curMonth = 1
  elif hMonth == "Cheshvan":
    curMonth = 2
  elif hMonth == "Kislev":
    curMonth = 3
  elif hMonth == "Tevet":
    curMonth = 4
  elif hMonth == "Shevat":
    curMonth = 5
  elif (hMonth == "Adar" and not curleapYear) or \
   (hMonth == "Adar I" and curleapYear):
    curMonth = 6
  elif hMonth == "Adar 2" and curleapYear:
    curMonth = 7
  
  monthsPassed = curMonth - 1 

  # Add the number of monthsPassed to total months:
  ttlMonths += monthsPassed

  # Use the average month which is 29 days, 12 hours, 793 chelakim to convert the 
  # total months into total chelakim:
  ttlChelakim =  (ttlMonths*29*24*1080)+(ttlMonths*12*1080)+(ttlMonths*793)
  
  # Add the orginal epoch which was Monday, 5 hours, 204 chelakim
  epoch0Chelakim = (24*1080)+(5*1080)+204
  ttl = ttlChelakim + epoch0Chelakim
  
  # Divide by a week in Chelakim units for the weeks since epoch 0: 
  weeksSinceCreation = ttl//(7*24*1080)

  # Get the chelakim into this week by subtracting the full weeks (in Chelakim)
  # from the total chelakim:
  chelakimIntoWeek = ttl - (weeksSinceCreation*(7*24*1080))

  # Convert the chelakim into week into hours and the remainder is the amount of chelakim: 
  hoursIntoWeek = chelakimIntoWeek//1080
  chelakimIntoWeek -= (hoursIntoWeek*1080)

  # Return how many hours and chelakim into the week the molad will be, what year 
  # it is out of 19-year cycle, and if it a leap year:
  return hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear

# Calculate the Molad:
def moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear):
  # Create a varible to store the how many days into the weeks the molad is.
  # Update the amount of hours into the week if there is a days in the hours:
  daysIntoWeek = hoursIntoWeek//24
  hoursIntoWeek = hoursIntoWeek%24
  
  # Create a list to store the data for the molad:
  molad = [daysIntoWeek, hoursIntoWeek, chelakimIntoWeek]

  # Return molad and where in the 19-cycle this year is:
  return molad, curYearInCycle
  

# Use the Four Gates to decide what type of year it is and when Rosh Hashana falls:
# (Remember daysIntoWeek starts counting from 0. Therefore, Sunday is 0.)
def fourGates(molad, curYearInCycle):
  # Create a list to store the details about the year:
  yearDetails = [None,None]
  
  # If molad greater than or equal to Saturday, 18 hours, and 0 chelakim:
  # (The year can be any out of the 19-year cycle.)
  if molad[0] == 6:
    if molad[1] >= 18: 
      # The year is deficient and Rosh Hashana is on day 2 of week:
      yearDetails = ["D", 2]
    
    # Otherwise, the molad must be greater than day 6, 20 hours, 491 chelakim:
    else:
      # The year is complete and Rosh Hashana is on day 7 of week:
      yearDetails = ["C", 7]

  
  # If Molad day is Sunday:
  elif molad[0] == 0: 
    
    # If its in years 3,6,8,11,14,17,19 in the cycle:
    if curYearInCycle in [3,6,8,11,14,17,19]:
      # If the molad falls at 20 hours and 491 chelakim or after: 
      if molad[1] > 20 or (molad[1] == 20 and molad[2] >= 491):
        # The year is complete and Rosh Hashana is on day 2 of week:
        yearDetails = ["C", 2] 
      # If the molad falls at 9 hours and 204 chelakim or after: 
      elif molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204): 
        # The year is deficient and Rosh Hashana is on day 2 of week:
        yearDetails = ["D", 2]

      #Otherwise, the molad is greater than Saturdays's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 2 of week:
        yearDetails = ["D", 2]

    # Otherwise it must be years 1,4,9,12,15,7,18,2,5,10,13, or 16 in the cycle:
    else:
      # If the molad falls at 9 hours and 204 chelakim or after:
      if molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204): 
        # The year is complete and Rosh Hashana is on day 2 of week:
        yearDetails = ["C", 2]

      #Otherwise, the molad is greater than Saturdays's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 2 of week:
        yearDetails = ["D", 2]

  # If Molad day is Monday:
  elif molad[0] == 1: 

    # If its in years 3,6,8,11,14,17,19, 2,5,10,13,16 in the cycle:
    if curYearInCycle in [3,6,8,11,14,17,19] or curYearInCycle in [2,5,10,13,16]:
      # If the molad falls at 18 hours and 0 chelakim or after: 
      if molad[1] >= 18:
        # The year is regular and Rosh Hashana is on day 3 of week:
        yearDetails = ["R", 3] 

      # If the molad falls at 15 hours and 589 chelakim or after: 
      elif molad[1] > 15 or (molad[1] == 15 and molad[2] >= 589): 
        # The year is complete and Rosh Hashana is on day 2 of week:
        yearDetails = ["C", 2]

      #Otherwise, the molad is greater than Sunday's last molad time:
      else:
        # The year is regular and Rosh Hashana is on day 2 of week:
        yearDetails = ["C", 2]

    # Otherwise it must be years 1,4,9,12,15,7,18 in the cycle :
    else:
      # If the molad falls at 15 hours and 589 chelakim or after: 
      if molad[1] > 15 or (molad[1] == 15 and molad[2] >= 589): 
        # The year is regular and Rosh Hashana is on day 3 of week:
        yearDetails = ["R", 3]

      #Otherwise, the molad is greater than Sunday's last molad time:
      else:
        # The year is complete and Rosh Hashana is on day 2 of week:
        yearDetails = ["C", 2]

  # If Molad day is Tuesday:
  elif molad[0] == 2: 

    # If its in years 3,6,8,11,14,17,19:
    if curYearInCycle in [3,6,8,11,14,17,19]:
      # If the molad falls at 18 hours and 0 chelakim or after: 
      if molad[1] >= 18:
        # The year is deficient and Rosh Hashana is on day 5 of week:
        yearDetails = ["D", 5] 

      # If the molad falls at 9 hours and 204 chelakim or after: 
      elif molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204): 
        # The year is regular and Rosh Hashana is on day 3 of week:
        yearDetails = ["R", 3]

      #Otherwise, the molad is greater than Monday's last molad time:
      else:
        # The year is regular and Rosh Hashana is on day 3 of week:
        yearDetails = ["R", 3]

    # Otherwise it must be years 1,4,9,12,15,7,18,2,5,10,13, or 16:
    else:

      # If the molad falls at 9 hours and 204 chelakim or after: 
      if molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204): 
        # The year is regular and Rosh Hashana is on day 5 of week:
        yearDetails = ["R", 5]

      #Otherwise, the molad is greater than Monday's last molad time:
      else:
        # The year is regular and Rosh Hashana is on day 3 of week:
        yearDetails = ["R", 3]

  # If Molad day is Wedneday:
  elif molad[0] == 3: 

    # If its in years 3,6,8,11,14,17,19:
    if curYearInCycle in [3,6,8,11,14,17,19]:

      # If the molad falls at 11 hours and 695 chelakim or after: 
      if molad[1] > 11 or (molad[1] == 11 and molad[2] >= 695):
        # The year is complete and Rosh Hashana is on day 5 of week:
        yearDetails = ["C", 5] 

      #Otherwise, the molad is greater than Tuesday's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 5 of week:
        yearDetails = ["D", 5]    

    # Otherwise it must be years 1,4,9,12,15,7,18,2,5,10,13, or 16:
    else:

      # If the molad falls at 11 hours and 695 chelakim or after: 
      if molad[1] > 11 or (molad[1] == 11 and molad[2] >= 695):
        # The year is regular and Rosh Hashana is on day 5 of week:
        yearDetails = ["R", 5]

      #Otherwise, the molad is greater than Tuesdays's last molad time:
      else:
        # The year is regular and Rosh Hashana is on day 5 of week:
        yearDetails = ["R", 5]  

  # If Molad day is Thursday:
  elif molad[0] == 4: 

    # If its in years 3,6,8,11,14,17,19:
    if curYearInCycle in [3,6,8,11,14,17,19]:

      # If the molad falls at 18 hours and 0 chelakim or after: 
      if molad[1] >= 18:
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7] 

      # If the molad falls at 9 hours and 204 chelakim or after: 
      elif molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204):
        # The year is complete and Rosh Hashana is on day 5 of week:
        yearDetails = ["C", 5] 

      #Otherwise, the molad is greater than Wednesday's last molad time:
      else:
        # The year is complete and Rosh Hashana is on day 5 of week:
        yearDetails = ["C", 5]     

    # Otherwise it must be years 1,4,9,12,15,7,18,2,5,10,13, or 16:
    else:
      # If the molad falls at 18 hours and 0 chelakim or after: 
      if molad[1] >= 18:
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7]

      # If the molad falls at 9 hours and 204 chelakim or after: 
      elif molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204):
        # The year is complete and Rosh Hashana is on day 5 of week:
        yearDetails = ["C", 5]

      #Otherwise, the molad is greater than Wednesday's last molad time:
      else:
        # The year is regular and Rosh Hashana is on day 5 of week:
        yearDetails = ["R", 5]   

  # If Molad day is Friday:
  elif molad[0] == 5: 

    # If its in years 3,6,8,11,14,17,19:
    if curYearInCycle in [3,6,8,11,14,17,19]:
      # If the molad falls at 20 hours and 491 chelakim or after: 
      if molad[1] > 20 or (molad[1] == 20 and molad[2] >= 491):
        # The year is complete and Rosh Hashana is on day 7 of week:
        yearDetails = ["C", 7] 

      # If the molad falls at 0 hours and 408 chelakim or after: 
      elif molad[1] > 0 or (molad[1] == 0 and molad[2] >= 408):
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7] 

      #Otherwise, the molad is greater than Thursday's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7] 

    # If its in years 1,4,9,12,15:
    elif curYearInCycle in [1,4,9,12,15]:

      # If the molad falls at 0 hours and 408 chelakim or after: 
      if molad[1] > 0 or (molad[1] == 0 and molad[2] >= 408):
        # The year is complete and Rosh Hashana is on day 7 of week:
        yearDetails = ["C", 7]

      #Otherwise, the molad is greater than Thursday's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7]

    # Otherwise it must be years 7,18,2,5,10,13, or 16:
    else:
      # If the molad falls at 9 hours and 204 chelakim or after: 
      if molad[1] > 9 or (molad[1] == 9 and molad[2] >= 204):
        # The year is complete and Rosh Hashana is on day 7 of week:
        yearDetails = ["C", 7]

      #Otherwise, the molad is greater than thursday's last molad time:
      else:
        # The year is deficient and Rosh Hashana is on day 7 of week:
        yearDetails = ["D", 7]
  
  # If no yearDetails were aquired, send an error message:
  if yearDetails == [None, None]: 
    print("ERROR", flush=True)
  
  # Return details about the year
  return yearDetails

# Convert the hebrew date into the Modified Julian date:
def htoMJDDate(hDate, hMonth, hYear):
  # Create a variable to keep track of the current year. Start counting from 
  # year 1 since the "Modified Julian Date System" starts from tishrei 1, year 1:
  cur = 1

  # Create a varible to keep track of the elapsed days from the year:
  yearDays = 0

  # Calculate the total amount of days that have passed in the "Modified Julian Day":
  # Repeat these steps as long as the current year isnt the inputed year:
  while cur != hYear:
    # 1. Calculate the molad for Tishrei for current year:
    hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(cur, "Tishrei")
    molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear)
    
    # 2. Figure out how long the current year is:
    yearDetails = fourGates(molad, curYearInCycle)
        
    # 3. Add the correct amount of days for the current year to amount of days 
    # elapsed from the year: 
    # If the year is deficient, current year is 353 days 
    if yearDetails[0] == "D":
      yearDays += 353
    # If the year is regular, current year is 354 days 
    elif yearDetails[0] == "R":
      yearDays += 354
    # If the year is deficient, current year it is 355 days 
    elif yearDetails[0] == "C":
      yearDays += 355

    # 4. if the year is a leap year, add 30 days to the amount of days in the year:
    if curleapYear: yearDays += 30

    # 5. Update current year
    cur += 1

  # Calculate the molad for Tishrei for that hYear, which is now current:
  hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(cur, "Tishrei")
  molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear)
  # Figure out how long the year is:
  yearDetails = fourGates(molad, curYearInCycle)

  # Calculate the amount of full months in this year into days:
  # Create a varible to store the amount of days from the complete months:
  monthDays = 0
  # Calculate the amount of full months in this year into days:
  # (Assume the year is kesidrah and a non leap year for now)
  # If the hMonth is Tishrei, there are not full month days to add. 
  if hMonth == "Cheshvan":
    monthDays += 30
  elif hMonth == "Kislev":
    monthDays += (30 + 29)
  elif hMonth == "Tevet":
    monthDays += (30 + 29 + 30)
  elif hMonth == "Shevat":
    monthDays = (30 + 29 + 30 + 29)
  elif hMonth == "Adar" or hMonth == "Adar 1" or hMonth == "Adar 2":
    monthDays = (30 + 29 + 30 + 29 + 30)
  elif hMonth == "Nissan":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29)
  elif hMonth == "Iyar":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29 + 30)
  elif hMonth == "Sivan":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
  elif hMonth == "Tammuz":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
  elif hMonth == "Av":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
  elif hMonth == "Elul":
    monthDays = (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
  
  # Fix the number of days based on if its a leap year: 
  if curleapYear and hMonth in ["Adar 2", "Nissan", "Iyar", "Sivan", "Tammuz", \
                                "Av", "Elul"]:
                                monthDays += 30
  # Fix the number of days based on if its a deficent year: 
  if yearDetails[0] == "D" and hMonth in ["Tevet", "Shevat", "Adar", "Adar 1",\
                                          "Adar 2", "Nissan", "Iyar", "Sivan", \
                                          "Tammuz", "Av", "Elul"]:
                                          monthDays -= 1 
  # Fix the number of days based on if its a complete year: 
  if yearDetails[0] == "C" and hMonth in ["Kislev", "Tevet", "Shevat", "Adar",\
                                          "Adar 1","Adar 2", "Nissan", "Iyar", \
                                          "Sivan", "Tammuz", "Av", "Elul"]:
                                          monthDays += 1 
  # The Modified Julian day is the total amount of days passed calculated from 
  # they year and the months plus the date for the current month:
  ModifiedJulianDay = yearDays + monthDays + hDate
  
  # Return the Modifed Julian day:
  return ModifiedJulianDay

# Convert the Modified Julian Day to the English date 
def MJDDateToE(ModifiedJulianDay):
  # Create varibles to store the english day, month and year:
  eDate = 0
  eMonth = 0
  eYear = 0

  # If the MJD is in the first year, figure out the month based on 
  # the number of days. Find the date by subtracting the months passed from the
  # total Modifed Julian day:
  if ModifiedJulianDay <= 116 and ModifiedJulianDay > (24+31+30):
    eMonth = "December"
    eYear = -3761
    eDate = ModifiedJulianDay - (24+31+30)
  elif ModifiedJulianDay <= (24+31+30) and ModifiedJulianDay > (24+31):
    eMonth = "November"
    eYear = -3761
    eDate = ModifiedJulianDay - (24+31)
  elif ModifiedJulianDay <= (24+31) and ModifiedJulianDay > 24:
    eMonth = "October"
    eYear = -3761
    eDate = ModifiedJulianDay - (24)
  elif ModifiedJulianDay <= 24:
    eMonth = "September"
    eYear = -3761
    # add 6 to find the english date because the calandar starts on September 7th:
    eDate = ModifiedJulianDay + 6
  
  # If the MJD takes you past year -3761:
  elif ModifiedJulianDay > 116:
    # Subtract the days in year -3761 (September 7th to December):
    ModifiedJulianDay -= 116 
    # Update the eYear to be -3760:
    eYear = -3760

    # Since the year -3760 is a leap, set leap to True: 
    curLeapYear = True 

    # If there is more than 365 in the Modified Julian day, there is still a 
    # year to be added to the eYear. Otherwise, we have found the eYear:
    if ModifiedJulianDay >= 365:
        stillWholeYears = True  
    else:
      stillWholeYears = False 

    # Repeat these steps while there is still at least one whole year to add to
    # the eYear:
    while stillWholeYears:
      # Subtract the correct amount of days for current year from MJD and 
      # Add a 1 to the eYear:
      if curLeapYear:  
        ModifiedJulianDay -= 366
        # Since the eYear 0 isn't in the gregorian calendar, skip it:
        if eYear == -1:
          eYear += 2 
        # Otherwise, just add one year:
        else:
          eYear += 1 
      else: 
        ModifiedJulianDay -= 365
        # Since the eYear 0 isn't in the gregorian calendar, skip it:
        if eYear == -1:
          eYear += 2 
        # Otherwise, just add one year:
        else:
          eYear += 1 

      # Figure out if the next year is a leap year: 
      # (Every year that is divisable exactly by four is a leap year except for the 
      # years divisable 100. However, if it is divisable by 100 AND 400, it is a 
      # leap year.)
      if eYear % 4 == 0:
        if eYear % 100 == 0:
          if eYear % 400 == 0:
            curLeapYear = True 
          else:
            curLeapYear = False
        else:
          curLeapYear = True 
      else:
        curLeapYear = False 

      # Update if there are no more full years in the Modified Julian day to add 
      # to the eYear:
      if curLeapYear and ModifiedJulianDay < 366:
        stillWholeYears = False 
      elif not curLeapYear and ModifiedJulianDay < 365:
        stillWholeYears = False 
            
    # Figure out the eMonth:
    # If this year is not a leap year Febuary is 28 days:
    if not curLeapYear:
      if ModifiedJulianDay <= 31:
        eMonth = "January"
      elif ModifiedJulianDay <= 31+28 and ModifiedJulianDay > 31:
        eMonth = "February"
        ModifiedJulianDay -= 31
      elif ModifiedJulianDay <= 31+28+31 and ModifiedJulianDay > 31+28:
        eMonth = "March"
        ModifiedJulianDay -= 31+28
      elif ModifiedJulianDay <= 31+28+31+30 and ModifiedJulianDay > 31+28+31:
        eMonth = "April"
        ModifiedJulianDay -= 31+28+31
      elif ModifiedJulianDay <= 31+28+31+30+31 and ModifiedJulianDay > 31+28+31+30:
        eMonth = "May"
        ModifiedJulianDay -= 31+28+31+30
      elif ModifiedJulianDay <= 31+28+31+30+31+30 and ModifiedJulianDay > 31+28+31+30+31:
        eMonth = "June"
        ModifiedJulianDay -= 31+28+31+30+31
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31 and ModifiedJulianDay > 31+28+31+30+31+30:
        eMonth = "July"
        ModifiedJulianDay -= 31+28+31+30+31+30
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31+31 and ModifiedJulianDay > 31+28+31+30+31+30+31:
        eMonth = "August"
        ModifiedJulianDay -= 31+28+31+30+31+30+31
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31+31+30 and ModifiedJulianDay > 31+28+31+30+31+30+31+31:
        eMonth = "September"
        ModifiedJulianDay -= 31+28+31+30+31+30+31+31
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31+31+30+31 and ModifiedJulianDay > 31+28+31+30+31+30+31+31+30:
        eMonth = "October"
        ModifiedJulianDay -= 31+28+31+30+31+30+31+31+30
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31+31+30+31+30 and ModifiedJulianDay > 31+28+31+30+31+30+31+31+30+31:
        eMonth = "November"
        ModifiedJulianDay -= 31+28+31+30+31+30+31+31+30+31
      elif ModifiedJulianDay <= 31+28+31+30+31+30+31+31+30+31+30+31 and ModifiedJulianDay > 31+28+31+30+31+30+31+31+30+31+30:
        eMonth = "Demember"
        ModifiedJulianDay -= 31+28+31+30+31+30+31+31+30+31+30
    
    # If the year is a leap year, take into account that Febuary is 29 days:
    if curLeapYear:
      if ModifiedJulianDay <= 31:
        eMonth = "January"
      elif ModifiedJulianDay <= 31+29 and ModifiedJulianDay > 31:
        eMonth = "February"
        ModifiedJulianDay -= 31
      elif ModifiedJulianDay <= 31+29+31 and ModifiedJulianDay > 31+29:
        eMonth = "March"
        ModifiedJulianDay -= 31+29
      elif ModifiedJulianDay <= 31+29+31+30 and ModifiedJulianDay > 31+29+31:
        eMonth = "April"
        ModifiedJulianDay -= 31+29+31
      elif ModifiedJulianDay <= 31+29+31+30+31 and ModifiedJulianDay > 31+29+31+30:
        eMonth = "May"
        ModifiedJulianDay -= 31+29+31+30
      elif ModifiedJulianDay <= 31+29+31+30+31+30 and ModifiedJulianDay > 31+29+31+30+31:
        eMonth = "June"
        ModifiedJulianDay -= 31+29+31+30+31
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31 and ModifiedJulianDay > 31+29+31+30+31+30:
        eMonth = "July"
        ModifiedJulianDay -= 31+29+31+30+31+30
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31+31 and ModifiedJulianDay > 31+29+31+30+31+30+31:
        eMonth = "August"
        ModifiedJulianDay -= 31+29+31+30+31+30+31
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31+31+30 and ModifiedJulianDay > 31+29+31+30+31+30+31+31:
        eMonth = "September"
        ModifiedJulianDay -= 31+29+31+30+31+30+31+31
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31+31+30+31 and ModifiedJulianDay > 31+29+31+30+31+30+31+31+30:
        eMonth = "October"
        ModifiedJulianDay -= 31+29+31+30+31+30+31+31+30
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31+31+30+31+30 and ModifiedJulianDay > 31+29+31+30+31+30+31+31+30+31:
        eMonth = "November"
        ModifiedJulianDay -= 31+29+31+30+31+30+31+31+30+31
      elif ModifiedJulianDay <= 31+29+31+30+31+30+31+31+30+31+30+31 and ModifiedJulianDay > 31+29+31+30+31+30+31+31+30+31+30:
        eMonth = "Demember"
        ModifiedJulianDay -= 31+29+31+30+31+30+31+31+30+31+30
    
    # Now that the year and month has been subtracted from the Modified Julian
    # day, the remainingis the English date:
    eDate = ModifiedJulianDay

  # Return the english date, month, and year:
  return eDate, eMonth, eYear

# Convert the english day to the Modfied Julian Day 
def etoMJDDate(eDate, eMonth, eYear):
  ModifiedJulianDay = 0 
  monthDays = 0
  # If the eYear is in the -3761, calculate the months passed and add it to the 
  # Modified Julian Day:
  if eYear == -3761:
    # if english month is "September", subtract the first 6 days from the date
    # to get the real dates:
    if eMonth == "September":
      eDate -= 6
    elif eMonth == "October":
      ModifiedJulianDay += (30-6)
    elif eMonth == "November":
      ModifiedJulianDay += (30-6) + 31
    elif eMonth == "December":
      ModifiedJulianDay += (30-6) + 31 + 30 
    
    # Add the date to the Modified Julian Date:
    ModifiedJulianDay +=  eDate 

    # Return the Modified Julian Day:
    return ModifiedJulianDay
 
 # If a year is before -3761, send an error message: 
  elif eYear < -3761:
    return "ERROR: Cannot compute day before the first year in Hebrew calendar,\
    which is -3761"
  
  # Otherwise, the year must be greater than -3761:
  else:
    # Add the days passed from year -3761 and set current year to -3760:
    ModifiedJulianDay += (116)
    cur = -3760

    # Since year -3760 is a leap year, set leap year to True:
    curLeapYear = True 

    # Repeat these steps while the current year isn't the english year imputed:
    while cur != eYear:
      # Add the correct days to the ModifiedJulianDay
      # (If the currant year is year 0, there is no such year in the Gregorian 
      # calandar so dont add any days)
      if curLeapYear and cur != 0:  
        ModifiedJulianDay += 366
      elif not curLeapYear and cur != 0: 
        ModifiedJulianDay += 365
      
      
      #Update cur 
      cur += 1

      # Figure out if the next year is a leap year: 
      # (Every year that is divisable exactly by four is a leap year except for the 
      # years divisable 100. However, if it is divisable by 100 AND 400, it is a 
      # leap year.)
      if cur % 4 == 0:
        if cur % 100 == 0:
          if cur % 400 == 0:
            curLeapYear = True 
          else:
            curLeapYear = False
        else:
          curLeapYear = True 
      else:
        curLeapYear = False 
 
  # Figure out how many complete months in terms of days have passed:
  # Assume the year is a non leap year for now
  # (If the eMonth is January, there are not full month days to add.
  if eMonth == "February":
    ModifiedJulianDay += 31
  elif eMonth == "March":
    ModifiedJulianDay += (31 + 28)
  elif eMonth == "April":
    ModifiedJulianDay += (31 + 28 + 31)
  elif eMonth == "May":
    ModifiedJulianDay += (31 + 28 + 31 + 30)
  elif eMonth == "June":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31)
  elif eMonth == "July":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30)
  elif eMonth == "August":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30 + 31)
  elif eMonth == "September":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30 + 31 + 31)
  elif eMonth == "October":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30)
  elif eMonth == "November":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31)
  elif eMonth == "December":
    ModifiedJulianDay += (31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30)
  
  # If the year is a leap year, add a day if the leap MONTH has already passed: 
  if curLeapYear and eMonth not in ["February", "January"]:
    ModifiedJulianDay += 1 
  
  # Add the english date to the Modified Julian day:
  ModifiedJulianDay += eDate  

  # Return the Modified Julian day
  return ModifiedJulianDay

# Convert the Modfied Julian day into the Hebrew date:
def MJDToHDate(ModifiedJulianDay, stopAtYear=False):
  # Create varibles for hebrew date, month, and year:
  hDate = 1
  hMonth = 0
  hYear = 1

  # Set current year to the first year:
  cur = 1

  # Calculate the molad for Tishrei for the first year, which is cur:
  hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(cur, "Tishrei")
  molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear) 
  # Figure out how long the year is:
  yearDetails = fourGates(molad, curYearInCycle)

  # If the Modified Jullian day is greater than or equal to the first year length, there is still 
  # full year/s to calculate. The years length depends on if its a leap year and 
  # if the year is defienct, regular, or complete:
  if not curleapYear:
    if yearDetails[0] == "D" and ModifiedJulianDay >= 353:
      stillWholeYears = True
    elif yearDetails[0] == "R" and ModifiedJulianDay >= 354:
      stillWholeYears = True
    elif yearDetails[0] == "C" and ModifiedJulianDay >= 355:
      stillWholeYears = True
    else:
      stillWholeYears = False
  else:
    if yearDetails[0] == "D" and ModifiedJulianDay >= 383:
      stillWholeYears = True
    elif yearDetails[0] == "R" and ModifiedJulianDay >= 384:
      stillWholeYears = True
    elif yearDetails[0] == "C" and ModifiedJulianDay >= 385:
      stillWholeYears = True
    else:
      stillWholeYears = False
  
  # Repeate these steps while there is still whole years to add to the hYear:
  while stillWholeYears:
    # Update the Modified Julian date based on if the current year's length:
    # If the year is deficient, it is 353 days:
    if yearDetails[0] == "D":
      ModifiedJulianDay -= 353
      hYear += 1 
    # If the year is regular, it is 354 days:
    elif yearDetails[0] == "R":
      ModifiedJulianDay -= 354
      hYear += 1 
    # If the year is deficient, it is 355 days: 
    elif yearDetails[0] == "C":
      ModifiedJulianDay -= 355
      hYear += 1 
    
    # If the current year is a leap year, subtract 30 days from the MJD:
    if curleapYear: 
      ModifiedJulianDay -= 30

    
    # Update cur:
    cur += 1 

    # Calculate the molad for Tishrei for new current :
    hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(cur, "Tishrei")
    molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear) 
    # Figure out how long the year is:
    yearDetails = fourGates(molad, curYearInCycle)

    # If the Modified Jullian day is greater than or equal to the current year length, 
    # there is still full year/s to calculate. The years length depends on if
    # its a leap year and if the year is defienct, regular, or complete:    
    if not curleapYear:
      if yearDetails[0] == "D" and ModifiedJulianDay >= 353:
        stillWholeYears = True
      elif yearDetails[0] == "R" and ModifiedJulianDay >= 354:
        stillWholeYears = True
      elif yearDetails[0] == "C" and ModifiedJulianDay >= 355:
        stillWholeYears = True
      else:
        stillWholeYears = False
    else:
      if yearDetails[0] == "D" and ModifiedJulianDay >= 383:
        stillWholeYears = True
      elif yearDetails[0] == "R" and ModifiedJulianDay >= 384:
        stillWholeYears = True
      elif yearDetails[0] == "C" and ModifiedJulianDay >= 385:
        stillWholeYears = True
      else:
        stillWholeYears = False
  
  # If you would like the function to return the days into the year, return the
  # Modified Julian Date now. This is used for graphing the Tekufot.
  if stopAtYear:
    return ModifiedJulianDay

  # Start by seting the month to "Tishrei" and the date to the Modified Julian
  # date. In the case the date is in Tishrei, this will be the date.
  hMonth = "Tishrei"
  hDate = ModifiedJulianDay

  # If the year is not a leap year:
  if not curleapYear:
    # If the year is defiencent, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan and Kislev has 29 days)
    if yearDetails[0] == "D":
      if ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30:
        hMonth = "Adar"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 29 + 29)
      elif ModifiedJulianDay > 30 + 29:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 29)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30

    # If the year is regular, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan has 29 and Kislev has 30 days)
    elif yearDetails[0] == "R":
      if ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30+ 29 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30:
        hMonth = "Adar"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 29)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30


    # If the year is complete, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan and Kislev have 30 days)
    elif yearDetails[0] == "C":
      if ModifiedJulianDay > 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30+ 29 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30+ 29 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30:
        hMonth = "Adar"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 30 + 30)
      elif ModifiedJulianDay > 30 + 30:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 30)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30


  # If the year is a leap year:
  elif curleapYear:
    # If the year is defiencent, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan and Kislev has 29 days)
    # Adar 1 has 30 days and Adar 2 has 29
    if yearDetails[0] == "D":
      if ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30 + 30:
        hMonth = "Adar 2"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29 + 30:
        hMonth = "Adar 1"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 29 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 29 + 29 + 29)
      elif ModifiedJulianDay > 30 + 29 + 29:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 29 + 29)
      elif ModifiedJulianDay > 30 + 29:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 29)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30
    
    # If the year is regular, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan has 29 and Kislev has 30 days)
    elif yearDetails[0] == "R":
      if ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30 + 30:
        hMonth = "Adar 2"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29 + 30:
        hMonth = "Adar 1"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29 + 30 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 29 + 30:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 29:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 29)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30

    # If the year is complete, decide the month as follows. The hebrew 
    # day is the Modified Julian day minus the months passed:
    # (Cheshvan and Kislev have 30 days)
    elif yearDetails[0] == "C":
      if ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Elul"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29:
        hMonth = "Av"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30:
        hMonth = "Tammuz"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29:
        hMonth = "Sivan"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29 + 30:
        hMonth = "Iyar"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30 + 29:
        hMonth = "Nissan"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30 + 30:
        hMonth = "Adar 2"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29 + 30:
        hMonth = "Adar 1"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29 + 30)
      elif ModifiedJulianDay > 30 + 30 + 30 + 29:
        hMonth = "Shevat"
        hDate = ModifiedJulianDay - (30 + 30 + 30 + 29)
      elif ModifiedJulianDay > 30 + 30 + 30:
        hMonth = "Tevet"
        hDate = ModifiedJulianDay - (30 + 30 + 30)
      elif ModifiedJulianDay > 30 + 30:
        hMonth = "Kislev"
        hDate = ModifiedJulianDay - (30 + 30)
      elif ModifiedJulianDay > 30:
        hMonth = "Cheshvan"
        hDate = ModifiedJulianDay - 30

  return hDate, hMonth, hYear

# TEST CODE:

# # MKJD 1 == September 7 -3761 = 1st of Tishrei, 1
# ModifiedJulianDay = etoMJDDate(7, "September", -3761)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(1, "Tishrei", 1)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(1)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(1)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for Tishrei 1, 1 ___")
# print("MJD:", 1)

# print("++++++++")
# # MKJD 34 == October 10 -3761 = 4th of Cheshvan, 1
# ModifiedJulianDay = etoMJDDate(10, "October", -3761)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(4, "Cheshvan", 1)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(34)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(34)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 4th of Cheshvan, 1 ___")
# print("MJD:", 34)

# print("++++++++")
# # MKJD 85 == November 30 -3761 = 25th of Kislev, 1
# ModifiedJulianDay = etoMJDDate(30, "November", -3761)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(25, "Kislev", 1)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(85)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(85)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 25th of Kislev, 1 ___")
# print("MJD:", 85)

# print("++++++++")
# # MKJD 356 == August 27 -3760 = 1 Tishrei, 2
# ModifiedJulianDay = etoMJDDate(27, "August", -3760)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(1, "Tishrei", 2)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(356)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(356)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 1 Tishrei, 2 ___")
# print("MJD:", 356)

# print("++++++++")
# # MKJD 756 == October 1 -3759 = 16 Cheshvan, 3
# ModifiedJulianDay = etoMJDDate(1, "October", -3759)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(16, "Cheshvan", 3)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(756)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(756)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 16, Iyar, 3___")
# print("MJD:", 756)

# print("++++++++")
# # MKJD 5000 == 15, "May", -3747 = 8, "Sivan", 14
# ModifiedJulianDay = etoMJDDate(15, "May", -3747)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(8, "Sivan", 14)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(5000)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(5000)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 8, Sivan, 14___")
# print("MJD:", 5000)

# print("++++++++")
# # MKJD 378675 == 15, "May", -3747 = 8, "Sivan", 14
# ModifiedJulianDay = etoMJDDate(15, "June", -2724)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(4, "Tammuz", 1037)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(378675)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(378675)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 8, Sivan, 14___")
# print("MJD:", 5000)


# print("++++++++")
# # MKJD 378675 == 15, "May", -3747 = 8, "Sivan", 14
# ModifiedJulianDay = etoMJDDate(1, "January", -1)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(9, "Shevat", 3760)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(1373064)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(1373064)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 8, Sivan, 14___")
# print("MJD:", 5000)

# print("++++++++")
# # MKJD 378675 == 15, "May", -3747 = 8, "Sivan", 14
# ModifiedJulianDay = etoMJDDate(1, "January", 1)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(18, "Tevet", 3761)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(1373429)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(1373429)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for 8, Sivan, 14___")
# print("MJD:", 5000)

# print("++++++++")
# # MKJD 2111393 == June 23 2020 = 1st of Tamuz, 5780
# ModifiedJulianDay = etoMJDDate(20, "September", 1958)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(6, "Tishrei", 5719)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(2088470)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(2088470)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for Tammuz 1, 5780___")
# print("MJD:", (5780*365) + (30 + 30 + 30 + 29 + 30 + 29 + 30 + 29 + 30 + 1))

# print("++++++++")
# # MKJD 2111393 == June 23 2020 = 1st of Tamuz, 5780
# ModifiedJulianDay = etoMJDDate(25, "March", 2019)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(18, "Adar 2", 5779)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(2110571)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(2110571)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)

# print("___True MJD for Tammuz 1, 5780___")

# print("++++++++")
# # MKJD 2111393 == December 25 -1 = Tevet 11, 3761
# ModifiedJulianDay = etoMJDDate(25, "December", -1)
# print("___'etoMJDDate' says MJD", ModifiedJulianDay)

# ModifiedJulianDay = htoMJDDate(13, "Nissan", 5780)
# print("___'htoMJDDate' says MJD", ModifiedJulianDay)

# hDate, hMonth, hYear = MJDToHDate(2110951)
# print("___'MJDToHDate' says it's", hDate, hMonth, hYear)

# eDate, eMonth, eYear = MJDDateToE(2110951)
# print("____'MJDDateToE' says it's", eDate, eMonth, eYear)


#December 25 1

# More Test code:
# Calculating the molad and year details to make sure they are correct: 
# for i in range (1,11):
#   hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(i, "Tishrei")
#   molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear)
#   yearDetails = fourGates(molad, curYearInCycle)
#   print("Year", i, "Molad:", molad, "yearDetails:", yearDetails, curleapYear )

# Function to check if the Hebrew year inputed is a leap year and 
# if its deficient, regular, or complete:
def hebrewYearLengthChecker(year):
  # Calculate the molad for Tishrei for the year to see if its a leap year:
  hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear = monthsSinceMoladTohu(year, "Tishrei")
  molad, curYearInCycle = moladCalc(hoursIntoWeek, chelakimIntoWeek, curYearInCycle, curleapYear)
  # Figure out how long the year is:
  yearDetails = fourGates(molad, curYearInCycle)

  return yearDetails, curleapYear


# Function to check if the Gregorian year inputed is a leap year
def gregorianLeapYearChecker(year):
  # Find out if this year is a leap year: 
  if year % 4 == 0:
    if year % 100 == 0:
      if year % 400 == 0:
        curLeapYear = True 
      else:
        curLeapYear = False
    else:
      curLeapYear = True 
  else:
    curLeapYear = False 
  return curLeapYear

# Function to puts all the other functions together:
def dateConverter(HebreworGregorian, date, month, year, BCEorCE, afterSunset):
  # If the user would like to convert an Gregorian date,
  if HebreworGregorian == "gregorian" or HebreworGregorian == "Gregorian":
    # If the year is BCE, convert it to a the negtive number for the program
    # to be able to understand:
    if BCEorCE == "BCE":
      year = year *-1

    # Check the date is valid:
    # If the year is 0, it is in invalid year:
    if year == 0:
      return "ERROR: Gregorian calendar doesn't have a year 0. \nTry input again."
    
    # A year before 3761 BCE is invalid:
    if year < -3761:
      return "ERROR: Gregorian year must be 3761 BCE or after. \nTry input again."
        # A year before 3761 BCE is invalid:
    
    
    # If the user input an invalid month, send an error mesage:
    if month not in ["January", "February", "March", "April", "May", \
                     "June", "July", "August", "September", "October", \
                     "November", "December"]:
      return "ERROR: month isn't spelled correctly.  \nTry input again."
   
    # If the date is less than or equal to zero, send an error message:
    if date <= 0:
      return "ERROR: A valid date must be a postive integer. \nTry input again."
    
    # if the date is greater than 31 for certain months, the date is invalid:
    elif month in ["January", "March", "May", "July", "August",\
                 "October", "December"] and date > 31:
      return "ERROR: " + month +" only has 31 days. \nTry input again."
    
    # if the date is greater than 30 for certain months, the date is invalid:
    elif month in ["April", "June", "September", "November"] and date > 31:
      return "ERROR: " + month + " only has 30 days. \nTry input again."
    
    #Check if this year is a leap year:
    curLeapYear = gregorianLeapYearChecker(year)

    # If its a normal year, a date greater than 28 is invalid:
    if month == "February" and not curLeapYear and date > 28:
      return "ERROR: February only has 28 days in a non-leap year. \nTry input again."
      
    # If its a normal year, a date greater than 29 is invalid:
    elif month == "February" and curLeapYear and date > 29:
      return "ERROR: February only has 29 days in a leap year. \nTry input again."
      
    # Otherwise the date must be correct, so convert the Gregorian
    # date into the Modified Julian date:
    else:
      ModifiedJulianDay = etoMJDDate(date, month, year)
      # If the user says to convert this date after sunset, add 1 to the 
      # Modified Julian Day:
      if afterSunset == True:
        ModifiedJulianDay += 1 
      elif afterSunset != True and  afterSunset != False:
        return "ERROR: Please answer yes or no to if the date is after sunset. \nTry input again."
      # Convert the Modfied Julian Date into the Hebrew date:
      hDate, hMonth, hYear = MJDToHDate(ModifiedJulianDay)
      # Return the Hebrew Date:
      return "The Hebrew date is " + hMonth + " " + str(hDate) + ", " + str(hYear)

  # If the user would like to convert an Hebrew date,
  elif HebreworGregorian == "hebrew" or HebreworGregorian == "Hebrew":
    # Check the date is valid:
    # If the year is 0 or negitive, it is in invalid year:
    if year <= 0:
      return "ERROR: Hebrew year must be year 1 or later. \nTry input again."
    
    # If the date is less than or equal to zero, send an error message:
    if date <= 0:
      return "ERROR: A valid date must be a postive integer. \nTry input again."
    
    # If the user input an invalid month, send an error mesage:
    if month not in ["Tishrei", "Cheshvan", "Kislev", "Tevet", "Shevat", \
                     "Adar", "Adar 1", "Adar 2", "Nissan", "Iyar", \
                     "Sivan", "Tammuz", "Av", "Elul"]:
      return "ERROR: month isn't spelled correctly.  \nTry input again."
  
    # Calculate if the year inputed is a leap year and if deficent, regular or 
    # complete:
    yearDetails, curleapYear = hebrewYearLengthChecker(year)

    # If the year is not a leap year and the user types "Adar 1" or "Adar 2", 
    # send an error message:
    if month in ["Adar 1", "Adar 2"] and not curleapYear:
      return "ERROR: A non-leap year only has one Adar month. \n\
      Try again inputing \"Adar\"."
    
    # If the year is a leap year and the user types "Adar", 
    # send an error message:
    if month == "Adar" and curleapYear:
      return "ERROR: A leap year has two Adar months. \n\
      Try again inputing \"Adar 1\" or \"Adar 2\"."     
    
    # If the month is Cheshvan or Kislev and the year is complete,
    # send an error message if the date is greater than 30
    # invalid:
    if yearDetails[0] == 'C' and (month == "Cheshvan" or month == "Kislev") \
    and date > 30:
      return "ERROR: " + month +" only has 30 days in this year. \nTry input again."

    # If the month is Cheshvan or Kislev and the year is deficient,
    # send an error message if the date is greater than 29
    # invalid:
    if yearDetails[0] == 'D' and (month == "Cheshvan" or month == "Kislev") \
    and date > 29:
      return "ERROR: " + month +" only has 29 days in this year. \nTry input again."

    # If the month is Cheshvan and the year is regular,
    # send an error message if the date is greater than 29
    # invalid:
    if yearDetails[0] == 'R' and month == "Cheshvan" and date > 29:
      return "ERROR: " + month +" only has 29 days in this year. \nTry input again."
    
    # If the month is Kislev and the year is regular,
    # send an error message if the date is greater than 30
    # invalid:
    if yearDetails[0] == 'R' and month == "Kislev" and date > 30:
      return "ERROR: " + month +" only has 30 days in this year. \nTry input again."

    # If the date is greater than 29 for certain months, the date is invalid:
    if month in ["Tevet", "Adar", "Adar 2", "Iyar", "Tammuz",\
                 "Elul"] and date > 29:
      return "ERROR: " + month +" only has 29 days. \nTry input again."
    
    # If the date is greater than 30 for certain months, the date is invalid:
    if month in ["Tishrei", "Shevat", "Adar 1", "Nissan", "Sivan", \
                   "Av"] and date > 30:
      return "ERROR: " + month + " only has 30 days. \nTry input again."
    
    # If the year normal,
    # Otherwise the date must be correct.
    # Convert the Hebrew date into the Modfied Julian date:
    else:
      ModifiedJulianDay = htoMJDDate(date, month, year)
      # Convert the Modified Julain Date to the Gregorian date:
      eDate, eMonth, eYear = MJDDateToE(ModifiedJulianDay)

      # If the year is negitive, convert it to a postive number and 
      # print BCE
      if eYear < 0:
        eYear = eYear *-1
        BCEorCE = "BCE"
      else:
        BCEorCE = "CE"
      # Return the Gregorian Date:
      return "The Gregorian date is " + eMonth + " " + str(eDate) + ", " + str(eYear) + " " + BCEorCE 

  
  # Send an error message if the user types 'Hebrew' or 'Gregorian' wrong:
  else:
    return("Error: Please type 'Hebrew' to convert a Hebrew date or 'Gregorian' to convert a Gregorian date")

# Function to make the code user-friendly
def wrapperDateConverter():
  afterSunset = False
  BCEorCE = False 
  # Find out what type of date the user would like to convert:
  HebreworGregorian = input("Type 'Hebrew' to convert from a Hebrew date or \n'Gregorian' to convert from a Gregorian date: ")

  # If the user types in the an valid type of date, print what type of date he is converting:
  if HebreworGregorian == "gregorian" or HebreworGregorian == "Gregorian" or HebreworGregorian == "hebrew" or HebreworGregorian == "Hebrew":
    # Print the type of date they are converting:
    print("Converting a ", end="")
    if HebreworGregorian == "hebrew" or HebreworGregorian == "Hebrew":
      print("Hebrew date")
    elif HebreworGregorian == "gregorian" or HebreworGregorian == "Gregorian":
      print("Gregorian date")
    print("")
    # Show the user how to correctly type the months, what is a valid date and what is a valid year:
    if HebreworGregorian == "gregorian" or HebreworGregorian == "Gregorian":
      print("Make sure to input a valid date. A valid year is from year 3761 BCE and on.\n\
      Type the month as spelled below: \n\
        January\n\
        February\n\
        March\n\
        April\n\
        May\n\
        June\n\
        July\n\
        August\n\
        September\n\
        October\n\
        November\n\
        December")
    elif HebreworGregorian == "hebrew" or HebreworGregorian == "Hebrew":
      print("Make sure to input a valid date. A valid year is any year from 1 and on. \n\
      Type the month as spelled below: \n\
        Tishrei\n\
        Cheshvan\n\
        Kislev\n\
        Tevet\n\
        Shevat\n\
        Adar (or Adar 1 and Adar 2 for a leap year)\n\
        Nissan\n\
        Iyar\n\
        Sivan\n\
        Tammuz\n\
        Av\n\
        Elul")
    
    # Get the date, month, and year:
    # If converting the a Gregorian date, get if the year is BCE or CE and if the 
    # date is after sundown:
    if HebreworGregorian == "gregorian" or HebreworGregorian == "Gregorian":
      month = input("Type month name (capitalize the first letter): ")
      date = input("Type date (e.g. 25): ")
      afterSunset = input("Is the date after sunset? Type yes or no: ")
      year = input("Type year (e.g. 1999): ")
      BCEorCE = input("Type CE or BCE: ")

      # Convert the afterSunset varible into True or False:
      if afterSunset == "yes" or afterSunset == "Yes":
        afterSunset = True 
      elif afterSunset == "no" or afterSunset == "No":
        afterSunset = False 

    # Otherwise, convert the Hebrew date:
    else:
      month = input("Type month name (capitalize the first letter): ")
      date = input("Type date (e.g. 25): ")
      year = input("Type year (e.g. 5780): ")


    # Update the user as the program is running:
    print("")
    print("Converting", month, date, year, end="")
    # If the user had to specify BCE or CE print this out too:
    if BCEorCE: print("", BCEorCE, end="")
    if afterSunset: print(" after sunset", end="")
    print("...")

    # Convert the date:
    convertedDate = dateConverter(HebreworGregorian, int(date), str(month), int(year), BCEorCE , afterSunset)
    print(convertedDate)
    # Otherwise the user typed in the an invalid type of date so send an error message:
  else:
    print("ERROR: Type 'Hebrew' to convert from Hebrew date or  \n'Gregorian' to convert from a Gregorian date")

"""Use this code below to convert dates. 
*   Uncomment the function.
*   Click "Run all" under "Runtime" in the tool bar. 
*   Then, follow the instructions for how to input a date in the shell for this code
"""

#wrapperDateConverter()

"""# Tekufot Calculator

Week 4 coding assignment: calculate, and plot, the time of tekufat Nisan every year from briat ha'olam until the next 10,000 years. Do this according to Shmuel, Rav Ada, and the "true" zman from the astronomical equinox. Also list the time of birkat hachama, and the first night of Pesach, identifying any "problem" years where Pesach doesn't fall out in the spring.
"""

# Need to do:
# Figure out how to accurately plot the dates with Adar 1 and 2 
# list the time of birkat hachama, and the 
# first night of Pesach, identifying any "problem" years where Pesach doesn't fall out in the spring.

# The hebrew date of the tekufot according to Rav Shmuel. He is of the opinion 
# that a solar year is 365d, 6hr.
def tekufatShmuel(hYear, tekufa="Nissan"):
  # Create varibles to store the first Tekufa of Nissan which was at 6PM,
  # Tuesday, 23 Adar, year 1. Use the Modified Julian Day to store the date:
  MJD = 172
  hours = 0
  parts = 0 

  # If the tekufa isn't Nissan, update the starting time:
  # Each of the seasons are 91d,7hr,540p apart. Use this number and how many 
  # seasons apart each tekufa is to calculate the exact time:
  if tekufa != "Nissan":
    # Tammuz is the next tekufa after Nissan:
    if tekufa == "Tammuz":
      MJD = 263
      hours = 7
      parts = 540
    # Tishrei is two seasons before Nissan:
    elif tekufa == "Tishrei":
      MJD = -11
      hours = 9
      parts = 0
    # Tevet is one season before Nissan:
    elif tekufa == "Tevet":
      MJD = 80
      hours = 16
      parts = 540
    else:
      return "ERROR: Please try again spelling the desired tekufa correctly."
    
  # Calculate how many days passed since the Tekufa of the year 1 to the Tekufa
  # desired:
  while hYear != 1:
    MJD += 365
    hours += 6

    # Update hYear 
    hYear -= 1 
  
  # Simplify parts into hours and hours into days:  
  MJD = (hours//24)+MJD
  hours = (hours%24)+(parts//1080)
  parts = parts % 1080

  # Convert the Modified Julian Date into the hebrew date:
  hDate, hMonth, hYear = MJDToHDate(MJD)

  # If the Tekufa of Tishrei, year 1 is being converted, the MJD is -11.
  # Since the Modified Julian Date converter only works for days after day 1, 
  # year 1, do it manutally:
  if MJD == -11:
    hDate, hMonth, hYear = 18, "Elul", 0

  # For the graphing later, use the Modified Julian Date to find how many days
  # into the year current year have passed:
  daysIntoYear = MJDToHDate(MJD, stopAtYear=True)
  
  hebrewDate = [daysIntoYear, hDate, hMonth, hYear, [hours, parts]]

  
  return hebrewDate

print(tekufatShmuel(5780, "Tishrei"))

# The hebrew date of the tekufot according to Rav Shmuel. He is of the opinion 
# that a solar year is 365d, 5hr, 997p, 48s.
def tekufatRavAda(hYear, tekufa="Nissan"):
  # The Tekufat Nissan of year 1 was 0d, 9hr, 642p before the Molad of Nissan.
  # The molad for Nissan was on Tishrei 1, 9hr, 642p. 
  # The modifeid Julian day of Tishrei 1 of year 1 is 179
  MJD = 179
  hours = 0
  parts = 0
  seconds = 0

  # If the tekufa isn't Nissan, update the starting time:
  # Each of the seasons are 91d,7hr,519p,31s apart. Use this number and how many 
  # seasons apart each tekufa is to calculate the exact time:  
  if tekufa != "Nissan": 
    # Tammuz is the next tekufa after Nissan:
    if tekufa == "Tammuz":
      MJD = 270
      hours = 7
      parts = 519
      seconds = 31
    # Tevet is one season before Nissan:
    elif tekufa == "Tevet":
      MJD = 87
      hours = 16
      parts = 560
      seconds = 45
    # Tishrei is two seasons before Nissan:
    elif tekufa == "Tishrei":
      MJD = -4
      hours = 9
      parts = 41
      seconds = 14     
    else:
      return "ERROR: Please try again spelling the desired tekufa correctly."

  # Calculate how many days passed since the Tekufa of the year 1 to the Tekufa
  # desired. For each year, add 365d, 5hr, 997p, 48s:
  while hYear != 1:
    MJD += 365
    hours += 5
    parts += 997
    seconds += 48

    # Update hYear 
    hYear -= 1 
  
  # Simplify seconds into parts, parts into hours, and hours into days:  
  parts += (seconds//76)
  seconds = seconds % 76

  hours += (parts//1080)
  parts = parts % 1080

  MJD += (hours//24)
  hours = hours % 24

  # Convert the Modified Julian Date into the hebrew date:
  hDate, hMonth, hYear = MJDToHDate(MJD)
  
  # If the Tekufa of Tishrei, year 1 is being converted, the MJD is -4.
  # Since the Modified Julian Date converter only works for days after day 1, 
  # year 1, do it manutally:
  if MJD == -4:
    hDate, hMonth, hYear = 25, "Elul", 0
  
  # For the graphing later, use the Modified Julian Date to find how many days
  # into the year current year have passed:
  daysIntoYear = MJDToHDate(MJD, stopAtYear=True)

  hebrewDate = [daysIntoYear, hDate, hMonth, hYear, [hours, parts, seconds]]
  return hebrewDate

#print(tekufatRavAda(5780, "Tishrei"))

# The hebrew date of the astronomical tekufot of (only) Nissan. 
# Each solar year is 365d, 5hr, 48m, 45s, which converted to chelakim/s is 
# 365d, 5hr, 864p, 45s
def trueTekufat(hYear):
  # The spring equinox for Gregorian year 2020 was on March 20, 2020 at 3:50am
  # UTC. Convert this time to the hebrew date and into Hebrew hours and parts:
  MJD = etoMJDDate(20, "March", 2020) #+ 1
  hours = 9
  parts = 900
  seconds = 0 

  # If the year is later than 5780, add the solar year times the years passed 
  # to the known equinox:
  if hYear >= 5780:
    yearsPassed = hYear-5780
    MJD += (365*yearsPassed)
    hours += (5*yearsPassed)
    parts += (864*yearsPassed)
    seconds += (45*yearsPassed)

    # Simplify seconds into parts, parts into hours, and hours into days:  
    parts += (seconds//76)
    seconds = seconds % 76

    hours += (parts//1080)
    parts = parts % 1080

    MJD += (hours//24)
    hours = hours % 24

  
  # Otherwise, the year must be before the year of 5780:
  else:
    yearsPassed = 5780-hYear
    MJD -= (365*yearsPassed)
    hours -= (5*yearsPassed)
    parts -= (864*yearsPassed)
    seconds -= (45*yearsPassed)

    # If the seconds are negitive, upadate parts and seconds to be an accurate time:
    if seconds < 0:
      # One part = 76 seconds
      parts -= abs(seconds)//76
      seconds = 76 - (abs(seconds)%76)
    # If the parts are negitive, upadate hours and parts to be an accurate time:
    if parts < 0:
      # One hour = 1080 parts
      hours -= abs(parts)//1080
      parts = 1080 - (abs(parts)%1080)
    # If the hours are negitive, upadate hours and MJD to be an accurate time:
    if hours < 0:
      # One day = 24 hours
      MJD -= abs(hours)//24
      hours = 24 - (abs(hours)%24)
    if MJD < 0:
      return "ERROR: Please enter a year starting from year 1."

  # Convert the Modified Julian Date into the hebrew date:
  hDate, hMonth, hYear = MJDToHDate(MJD)
  
  # For the graphing later, use the Modified Julian Date to find how many days
  # into the year current year have passed:
  daysIntoYear = MJDToHDate(MJD, stopAtYear=True)

  hebrewDate = [daysIntoYear, hDate, hMonth, hYear, [hours, parts, seconds]]
  return hebrewDate
#print(trueTekufat(1))
 # 2020 was on March 20, 2020 at 3:49am
  # UTC.

# Create a list of the tekufot for Rav Ada, Shmuel and the Astronomical vernal
# equinox: 
def listOfTekufot(endYear, startYear=1):
  # Create an empty list to store the Tekufot and year
  listOfTekufotRavAda = []
  listOfTekufotShmuel = []
  listOfTekufotAstromoical = []

  # Create a list of the possible months
  for i in range(startYear, endYear+1):
    # Append the tekufa for each year first according to Shmuel , Rav Ada and 
    # astronomical year respectively:
    tekufatNissanShmuel = tekufatShmuel(i, "Nissan")
    tekufatNissanRavAda = tekufatRavAda(i, "Nissan")
    tekufatNissanAstromoical = trueTekufat(i)

    listOfTekufotRavAda += [tekufatNissanRavAda[0]]
    listOfTekufotShmuel += [tekufatNissanShmuel[0]]
    listOfTekufotAstromoical += [tekufatNissanAstromoical[0]]

  return listOfTekufotRavAda, listOfTekufotShmuel, listOfTekufotAstromoical
  
def years(endYear, startYear=1):
  years = []
  for i in range(startYear, endYear+1):
    # Add the current year for each tekufa calculated:
    years += [i]
  return years
#print(listOfTekufot(1))

# # importing the required module 
# import matplotlib.pyplot as plt 
# import numpy as np
# from matplotlib.ticker import MultipleLocator

# # Change the size of the graph:
# plt.rcParams["figure.figsize"] = (20,10)

# # Set the y tick marks as the hebrew months:
# plt.yticks([1,31,60,90,119,149,179,208,238,267,297,327,356,386], \
#            ["Tishrei", "Cheshvan,", "Kislev", "Tevet", "Shevat", "Adar 1", \
#             "Adar 2", "Nissan", "Iyar", "Sivan", "Tammuz", "Av", "Elul"])

# # Turn on the smaller tick marks:
# plt.minorticks_on()

# # Create a list to store each year to plot:
# points = 3000
# startYear = 1
# x = years(points, startYear)

# # Calculate the days into the year each tekufa falls: 
# listOfTekufotRavAda, listOfTekufotShmuel, listOfTekufotAstromoical = listOfTekufot(points)  

# # plotting points as a scatter plot: 
# shmuel = plt.scatter(x, listOfTekufotShmuel, label= "Shmuel", color= "green",  
#             marker= "*", s=30) 

# # plotting points as a scatter plot: 
# ravAda = plt.scatter(x, listOfTekufotRavAda, label= "Rav Ada", color= "blue",  
#             marker= ".", s=30) 

# # plotting points as a scatter plot: 
# trueTekufot = plt.scatter(x, listOfTekufotAstromoical, label= "Astronomical Tekufa", color= "red",  
#             marker= "+", s=30) 
# # x axis name: 
# plt.xlabel('Hebrew Year') 
# # y axis name:
# plt.ylabel('Hebrew Month') 

# # title for gragh:
# plt.title('Shmuel, Rav Ada, and Astronomical Tekufot') 

# # Create a legend:
# plt.legend(handles=[shmuel, ravAda, trueTekufot])

# # function to show the plot 
# plt.show()

# A function that calculates Birkat Hachama from year 1 until end year. 
# Birkat Hachama  is when the sun returns to 
# same place it was when when the world was created:
def birkatHachama(endYear):
  # Create a list to store all the times of Birkat hachama:
  years = []

  # The first Birkat Hachama was when the sun was on at 6pm on the 28th of Elul,
  # year 1. Convert this time to the hebrew date and into Hebrew hours and parts:
  MJD = 354
  hours = 0

  # For the graphing later, use the Modified Julian Date to find how many days
  # into the year current year have passed:
  daysIntoYear = MJDToHDate(MJD, stopAtYear=True)

  hDate, hMonth, hYear = MJDToHDate(MJD)
  years += [[daysIntoYear, hDate, hMonth, hYear, [hours]]]  

  # Calculate how many days passed since the Birkat of the year 1 to the Tekufa
  # desired:
  while endYear != 1:
    MJD += 365
    hours += 6

    # For the graphing later, use the Modified Julian Date to find how many days
    # into the year current year have passed:
    daysIntoYear = MJDToHDate(MJD, stopAtYear=True)

    hDate, hMonth, hYear = MJDToHDate(MJD)
    years += [[daysIntoYear, hDate, hMonth, hYear, [hours]]]
    # Update hYear 
    endYear -= 1 
  return years

years = birkatHachama(2)
print(years)
for i in range (len(years)):
  x = years[i][3]
  y = years[i][0]
  print(x,y)

# Change the size of the graph:
plt.rcParams["figure.figsize"] = (20,10)

# Set the y tick marks as the hebrew months:
plt.yticks([1,31,60,90,119,149,179,208,238,267,297,327,356,386], \
           ["Tishrei", "Cheshvan,", "Kislev", "Tevet", "Shevat", "Adar 1", \
            "Adar 2", "Nissan", "Iyar", "Sivan", "Tammuz", "Av", "Elul"])

# Turn on the smaller tick marks:
plt.minorticks_on()

# Create a list to store each year to plot:
years = birkatHachama(5)
for i in range (len(years)):
  x = years[i][3]
  y = years[i][0]
  # plotting points as a scatter plot: 
  birkatHachama = plt.scatter(x, y, label= "Birkat Hachama", color= "green", marker= "*", s=30) 

# x axis name: 
plt.xlabel('Hebrew Year') 
# y axis name:
plt.ylabel('Hebrew Month') 

# title for gragh:
plt.title('Birkat Hachama') 

# Create a legend:
plt.legend(handles=[birkatHachama])

# function to show the plot 
plt.show()



list = [1,2,3],["a","b","c"]
x = list[0][2]
print(x)

"""# Longitude of the Sun in terms of time

This week's coding assignment will take at least two weeks, and we will need to supplement some of the reading with more modern (i.e., Keplerian) astronomy.
But the basic problem is this: write a code that plots the longitude of the sun (how many degrees it has moved from the beginning of the Aries constellation) as a function of time (day of the year) for the following models:
perfect geocentric model with uniform circular motion
off-center geocentric model where the sun is on uniform circular motion, but the center of the orbit is off-set from the center of the earth by 2% of the radius of the orbit
geocentric model with the sun on an epicycle with radius 2% of the mean orbit
heliocentric model with Earth on elliptical orbit with eccentricity of 2%
"""

import matplotlib.pyplot as plt
import math

# Plots the longitude of the sun as a function of time. 
# Model 1: Perfect geocentric model where the sun is on uniform circular motion
def longitudeInPerfectGeocentric(MJD):
  # Calculate the amount of days passed since the MJD inputed and the MJD for 
  # 3rd of Nissan, 4938, which is 1803407 in MJD. This is the start date for the 
  # Rambam:
  daysPassed = MJD - 1803407
  # A varible to store the days passed and not be changed in the future:
  days = daysPassed

  # Create varibles to store mean degrees, minutes, and seconds. Set each varible to
  # the orginal amount at 6pm on the 3rd of Nissan 4938:
  meanDegrees = 7
  meanMinutes = 3
  meanSeconds = 32 
  meanTotal = [meanDegrees, meanMinutes, meanSeconds]

  # Since this model is perfect, the earth is exactly in the center of the 
  # sun's orbit. Therefore, there is no apogee.

  # Run the meanTotal and daysPassed through the function addDegrees(degrees, 
  # minutes, seconds, meanTotal, daysPassed, atLeast)
  # While there is still at least x days left in days passed, keep
  # adding the correct amount of mean degrees:
  meanTotal, daysPassed = addDegrees(136, 28, 20, meanTotal, daysPassed, 10000)
  meanTotal, daysPassed = addDegrees(265, 38, 50, meanTotal, daysPassed, 1000)
  meanTotal, daysPassed = addDegrees(98, 33, 53, meanTotal, daysPassed, 100)
  meanTotal, daysPassed = addDegrees(9, 51, 23, meanTotal, daysPassed, 10)
  meanTotal, daysPassed = addDegrees(0, 59, 8, meanTotal, daysPassed, 1)

  # Simplify the seconds into minutes and minutes into degrees. Also, simplify 
  # they degrees to be 0 through 360. 
  meanTotal = simplify(meanTotal)
    

  # Convert the degrees of seconds and minutes into one numbers:
  degrees = meanTotal[0] + (meanTotal[1]/60) + ((meanTotal[2])/3600)
  radians = degrees * (math.pi / 180)

  return meanTotal, radians, days

def graph():
  # Create lists to store the information to plot:
  meanTotalList = []
  
  graphradiansList = []
  daysList = [] 
  
  polarRadiansList = []
  radiusList = []
  
  MJD = 1803408
  for i in range(1,365):
    MJD += 1
    meanTotal, radians, days = longitudeInPerfectGeocentric(MJD)
    # For seeing how far it has moved from Aries, subtract 180 degrees if the degrees
    # is more than 180 degrees:
    if radians > (math.pi):
      graphRadians = (2*math.pi)- radians 
    else:
      graphRadians = radians
    
    # Add the new infomation to the list of plots:
    meanTotalList += [meanTotal]
    
    graphradiansList += [graphRadians]
    daysList += [days]  
    
    polarRadiansList += [radians]
    radiusList += [4]
  
  # Create figures:
  fig = plt.figure()
  ax1 = plt.subplot(121)
  ax2 = plt.subplot(122, projection='polar')
  
  # Plot figures:
  ax1.scatter(daysList, graphradiansList, c="Blue", s=1)
  ax2.scatter(polarRadiansList,radiusList, c="Blue", s=1)
  # Plot sun in polar graph:
  ax2.scatter(0, 0, c="Green", s=100)
  plt.show()

# A function to add degrees:
def addDegrees(degrees, minutes, seconds, meanTotal, daysPassed, atLeast):
  while daysPassed // atLeast  != 0:
    # Add the correct amount of time to degress, minutes, seconds:
    meanTotal[0] += degrees
    meanTotal[1] += minutes
    meanTotal[2] += seconds 

    daysPassed -= atLeast
  return meanTotal, daysPassed

 # A function to simplify seconds into minutes and minutes into degrees.
 # Also, it simplifies degrees to be between 0 and 360:
def simplify(list):
  list[1] += (list[2]//60)
  list[2] = list[2] % 60

  list[0] += (list[1]//60)
  list[1] = list[1] % 60
  
  # Get rid of mulitiples of 360 in the degrees:
  list[0] = list[0] % 360

  return list

graph()
#longitudeInPerfectGeocentric(1803407)

# Plots the longitude of the sun as a function of time. 
# Model 2: off-center geocentric model where the sun is on uniform circular motion, 
# but the center of the orbit is off-set from the center of the earth by 2% of the radius of the orbit
def longitudeInGeocentric2Percent(MJD):
  # 1. Calculate the Perfect Geocentric Model, where the earth is at the center of the orbit:
  meanTotal, radians, days = longitudeInPerfectGeocentric(MJD)
  
  # The position of the sun is given by the formula:
  # S = (x,y) = [d*cos(w), d*sin(w)] + [r*cos(lambda1), r*sin(lambda1)]
  # where d = distance from earth to the center of sun's orbit,
  # w = the longitude of the apogee, r = distnace from the center of the sun's
  # orbit to the orbit, and lambda1 = is the mean postition of the sun:
  
  # In our case, d = 0.02 because the earth is off center by 2% of the radius of the orbit.
  # w = 86d, 45m, 8s according to the Rambam, which is  lambda1 = meanTotal 
  # R is canceled out eventually, so it doesn't have to be included:
  # S = (x,y) = [0.02*cos([86d, 45m, 8s]), 0.02*sin([86d, 45m, 8s])] 
  #           + [cos(meanTotal), sin(meanTotal)]
  
  x = (0.02*math.cos(86+(45/60)+(8/3200))) + math.cos(meanTotal[0]+(meanTotal[1]/60)+(meanTotal[2]/3200))
  y = (0.02*math.sin(86+(45/60)+(8/3200))) + math.sin(meanTotal[0]+(meanTotal[1]/60)+(meanTotal[2]/3200))
  
  # Lambda2, the angle which we are trying to calculate is the arctan of (x,y) points:
  xcord = math.atan(x)
  ycord = math.atan(y)

  # Convert the x,y corrdinates to be a point on a polar graph
  # Radius = (x^2 + y^2) ^ 1/2
  # Theta = taninverse(y/x)
  radius = math.sqrt((xcord)**2 +(ycord)**2)
  theta = math.atan(ycord/xcord)
  
  return theta, radius, days 



def graph(days):
  # Create lists to store the information to plot:
  daysList = [] 
  radiusList = []
  thetaList = []
  
  MJD = 1803408
  for i in range(days):
    MJD += 1
    theta, radius, days = longitudeInGeocentric2Percent(MJD)
    
    daysList += [days]  
    thetaList += [theta]
    radiusList += [radius]

  # Create figures:
  fig = plt.figure()
  ax1 = plt.subplot(121)
  ax2 = plt.subplot(122, projection='polar')
  
  # Plot figures:
  ax1.scatter(daysList,thetaList)
  ax2.scatter(thetaList,radiusList)
  # Plot sun in polar graph:
  ax2.scatter(0, 0, c="Green", s=100)
  plt.show()

print(longitudeInGeocentric2Percent(1803407))
graph(365)